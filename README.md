# Retro Remaster - Handout

### Points
80

---

### Due Date
09/27/2024

---

### Goal
To showcase your use of the fundamental Game Engine skills by creating a remaster of an arcade game in Unity.

---

### Instructions
1. Create a Fork of this repository by clicking the 'Fork' button at the top-right of this page. Set the Repository Name to be 'LastNameFirstInitial-Retro-Remaster' (without the quotes). For example, mine would be 'HerreraSturmD-Retro-Remaster' (without the quotes). Click 'Create Fork'

2. Use your preferred GitHub client (SourceTree, Bash, etc.) to clone your fork of the repository into your student folder under 'E:\VGD\YOUR_STUDENT_NUMBER'.

3. Open the project in Unity Hub by clicking 'Add' and then looking for where you cloned the repository and selecting the repository folder. Make sure you're using Unity 2022.1.22f1! You can now begin creating your game.

4. We will have several lessons in class during the duration of the project, each going over different Game Engine skills. You must create a remaster of an arcade game in Unity using those skills. The way you implement it is up to you, but each skill must be present. For example, one day, we may learn how to manipulate velocity and you would implement that into your game in some way, such as making the player move when a button is pressed, adding a jump, etc. Another day, we may learn how to change the animation that's playing and you would implement that by adding enemy animations, animating tiles in your level, making an animated title screen, etc. If you have trouble getting started, there are some examples that you can base yours off of.

5. Every day, before you leave class, stage, commit, and push to GitHub. This will allow you to work from home if you want. If you decide to do that, don't forget to also stage, commit, and push anytime you finish working at home.

---

### Skills Rubric (12)
| Skill    | Introductory (1) | Developing (2) | Proficient (3) | Advanced (4) |
| -------- | ----------------------------------- | -------------------------------- | --------------------------- | ----------------------------- |
| GAM.FUN.1: Use GameObjects to Represent Entities | Student may be able to describe what a GameObject does in a game, but can't yet create or manipulate one using scripts | Student can explain what a GameObject does in a game and can create and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a GameObject does in a game and can consistently and efficiently create and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.2: Use Components to Represent Behaviors/Data | Student may be able to describe what a Component does in a game, but can't yet add or manipulate one using scripts | Student can explain what a Component does in a game and can add and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Component does in a game and can consistently and efficiently add and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.3: Use Scenes to Represent Levels and Menus | Student may be able to describe what a Scene does in a game, but can't yet load or manipulate one using scripts | Student can explain what a Scene does in a game and can load and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Scene does in a game and can consistently and efficiently load and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.4: Read and Interpret Device Input | Student may be able to describe what Device Input is needed for in a game, but can't yet read or interpret it using scripts | Student can explain what Device Input is needed for in a game and can read and/or interpret it using scripts, but not yet consistently or efficiently | Student understands exactly what Device Input is needed for in a game and can consistently and efficiently read and interpret it using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.5: Read and Manipulate Transform Data | Student may be able to describe what a Transform is in math, but can't yet read or manipulate one using scripts | Student can explain what a Transform is in math and can read and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Transform is in math and can consistently and efficiently read and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.6: Read and Manipulate Physics Bodies | Student may be able to describe what a Rigidbody is in physics, but can't yet read or manipulate one using scripts | Student can explain what a Rigidbody is in physics and can read and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Rigidbody is in physics and can consistently and efficiently read and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.7: Listen For and Resolve Collisions | Student may be able to describe what collisions are needed for in a game, but can't yet listen for or manipulate one using scripts | Student can explain what collisions are needed for in a game and can listen for and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what collisions are needed for in a game and can consistently and efficiently listen for and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.8: Resolve an Animation Using Parameters | Student may be able to describe what Animations are needed for in a game, but can't yet read or manipulate one using scripts | Student can explain what Animations are needed for in a game and can read and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what Animations are needed for in a game and can consistently and efficiently read and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.9: Represent Object Archetypes vs. Instances | Student may be able to describe the relationship between Archetypes and Instances, but can't yet use them together using scripts | Student can explain what the relationship between Archetypes and Instances is and can create an Instance from an Archetype, but not yet consistently or efficiently | Student understands exactly the relationship between Archetypes and Instances and can consistently and efficiently create an Instance from an Archetype using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.FUN.10: Display/Read Data Using User Interfaces | Student may be able to describe what a User Interface is in a game, but can't yet listen for or manipulate one using scripts | Student can explain what a User Interface is in a game and can listen for and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a User Interface is in a game and can consistently and efficiently listen for and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.2D.1: Read and Manipulate Sprite Data | Student may be able to describe what a Sprite does in a game, but can't yet read or manipulate one using scripts | Student can explain what a Sprite does in a game and can read and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Sprite does in a game and can consistently and efficiently read and manipulate one using scripts using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |
| GAM.2D.2: Layout Complex Levels Using Tilemaps | Student may be able to describe what a Tilemap does in a game, but can't yet read or manipulate one using scripts | Student can explain what a Tilemap does in a game and can read and/or manipulate one using scripts, but not yet consistently or efficiently | Student understands exactly what a Tilemap does in a game and can consistently and efficiently read and manipulate one using scripts | Student can do all of the above, as well as teach it to someone else, generalize it to another software, and/or implement their own unique example of how to use them |

---

### Vocab (1)
- Entity: Generic way to refer to a 'thing' in an engine. These are called 'GameObjects' in Unity, 'Actors' in Unreal Engine, etc.

---

### Evaluation Procedure
1. Anytime you're evaluated for a skill, you can score anywhere from a 0 to a 4 on that skill. If you score less than a 'Proficient' (3), then you need to continue working on the skill before you start the next project. Your grade for the project is never set in stone and can move up once you feel like you've improved in any given skill, you just need to be re-evaluated. The only deadlines in which a grade can't be improved are at the end of each quarter. The 5 different levels that you can score for each skill are:
    - No Attempt (0): The skill was not used or attempted in any way in your project.
    - Introductory (1): Definition outlined in Skills Rubric above.
    - Developing (2): Definition outlined in Skills Rubric above.
    - Proficiency (3): Definition outlined in Skills Rubric above.
    - Advanced (4): Definition outlined in Skills Rubric above.

2. Your total grade on the project will be based on all the individual skill grades that were recorded, added together and adjusted to be worth the number of points that the project is worth (aka, each skill will be worth an equal part of your grade relative to the number of skills assessed and how many points the project is worth). For example, if a project is worth 80 points and there are 10 skills, then each skill is worth 8 points. For that skill, you will receive a percentage of 8 points based on whether you got a 0, 1, 2, 3, or 4 on the scale explained above. For example, if you got a 1, you'd get 2 points for that skill (since 1/4 of 8 is 2). This will be added together to determine your total grade for the project.

3. You'll be given multiple opportunities to correct your work until submission and you can always re-submit past the due date for a better grade with no penalty. Late penalties in general are not applied to assignments. Instead, your professionalism grade might take a hit for late submissions. This only applies if the initial submission is late, not any following submissions to improve your work. Sometimes, there are accentuating circumstances and if you let me know in advance, I will most likely be reasonable regarding lifting penalties unless you are just procrastinating on doing work.

4. Your grade for the project will be rounded to the nearest whole number. Your grade in the gradebook will be a reflection of whatever your most recent evaluation scored as long as each skill was at a 'Proficient' or higher. You can resubmit as much as you like before the end of the current quarter.

---

### How to Submit
Create a Pull Request on GitHub and have a 2nd-Year student approve it up to the day before the project is due. The 2nd-Year will only approve it if you've reached at least 'Proficient' on each skill. If you haven't, they will tell you where you need to improve. You can make multiple pull requests before the project is due, so don't wait until the last minute! Once your request is approved, your project will be submitted and you will be ready for your evaluation with the instructor on the day the project is due. Again, you can always resubmit by creating a new pull request.

---

### Success Criteria
I am successful once I have shown mastery in each skill by scoring at least a 'Proficient' on each one during my evaluation with my instructor.

---

### Examples
https://drive.google.com/drive/folders/1ogJt71DzE2urK3c1VvOjDMAllV3dhRqY?usp=drive_link
